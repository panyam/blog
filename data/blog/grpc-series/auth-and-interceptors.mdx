---
title: 'Part 4 - Authentication, Middleware and Interceptors'
date: 2023-02-20T15:32:14Z
lastmod: '2022-05-05'
tags: ['grpc', 'buf', 'build tooling', 'plugin management']
draft: true
summary: 'Buf.build is a modern ecosystem simplifying the plugin management when building gRPC services and addresses several pains and short-comings found in the original gRPC build ecosystem'
layout: PostSimple
---

## Introduction

We concluded the [last part](/blog/grpc-series/simple-grpc-service/) by generating a grpc gateway service to act as a proxy in front of our grpc music service.  This service would convert familiar REST/HTTP requests from clients to/from our grpc services.  We also briefly discussing how the protoc utility orchestrates different plugins in generating different kinds of artifacts - via stdin and stdout.


This gateway was generated by using a grpc-gateway plugin and annotating our rpc methods by http method, bindings and parameter details.  We also generated openapi specs for our generated gateway service so it could be viewed in the SwaggerUI too.

A key part of our workflow so far was:

* using custom plugins (grpc-gateway)
* adding a call to the custom plugins in our Makefile (eg protoc `--<pluginname>_out=....`)

To our dismay we also discovered protoc did not offer much in the way of package management so when it was time use Google's http annotations, we had to manually copy a bunch of third party/vendor proto files to access them.  Clearly this is a burden and only increases as codebases become larger and larger.  Even worse when code bases have dependencies to resolve (either from other parts of the codebases or from third party vendors) managing this burden because a daunting and error-prone task for developers.   Another area we have been carefully avoiding (but will only get harder with larger codebases) is that of testing, validation, collaboration between developers when using plugins in our grpc services.

What is needed are tools to:

* manage dependencies between proto packages within a project
* manage dependencies between several plugin/annotation providers
* generate artifacts and manage output dirs etc inherently instead of having to worry about output paths etc
* validate/enforce coding conventions and standards (via linting tools)
* improve collaboration between teams and organizations.

[Buf.build](https://buf.build/) is one such tool that comes to our rescue.  In this article we will provide a brief overview of Buf, its capabilities and convert our canonical running example - the musicservice - to use Buf.build for generating all required artifacts.   We will also remove any copied annotations and instead use Buf's package management and repositories to access them.

## What is Buf.build?

[Buf.build](https://github.com/bufbuild/buf) is an open source tool for managing protobuf files and plugins.   With Buf.build inting, building, testing protobuf files is simplified as well as generating code from them.  Buf.build has made it easier for developers new to protobufs to work with protobufs by unifiying several aspects of the protobuf related workflows under one roof.

Some of the key features of Buf.build are:
* Repository management for plugins for easy discovery and accessibility
* Linting for checking syntax errors and style violations in protobuf files
* Testing for protobuf files to ensure behaviours and catching any regressions
* Building protobuf files into binary and JSON representations to be used in several environments and contexts (gRPC, REST etc)
* Code generation for a variety of programming languages by invoking and managing plugins (without placing the burden of installing and maintaining these plugins on the developer).  This is especially valuble as a lot of repetitive tasks are automated saving valuble developer time.

III. Key Benefits of Using Buf.build

Buf.build offers several benefits to developers and organizations, including:

Improved Code Quality: Buf.build can help improve code quality by enforcing best practices and identifying potential issues early in the development cycle. It can catch syntax errors, style violations, and other issues before they make it into production, ensuring that code is clean and maintainable.
Faster Builds: Buf.build can speed up builds by only rebuilding what's necessary and parallelizing operations. This means that developers can iterate faster and get feedback sooner, leading to shorter development cycles and faster time-to-market.
Better Collaboration: Buf.build can make it easier for teams to collaborate by providing a single source of truth for code, enforcing consistent standards, and enabling easy integration with other tools. This can help teams work more efficiently and reduce the risk of errors and conflicts.
Buf.build has been used successfully by many organizations, such as Lyft, Google, and CoreOS, to manage large and complex codebases.

IV. Getting Started with Buf.build

To get started with Buf.build, you'll need to install the Buf.build CLI, which is available for macOS, Linux, and Windows. You'll also need to have a protobuf file or a set of files that you want to work with.

Once you've installed Buf.build, you can run various commands to lint, build, and test protobuf files. For example, to lint a protobuf file, you can use the following command:

```
buf lint path/to/my.proto
```

This will run the linting process and provide feedback on any syntax errors, style violations, or other issues in the protobuf file.

To build a protobuf file, you can use the following command:

```
buf build path/to/my.proto
```

This will generate the binary or JSON representation of the protobuf file, which can be used in various contexts such as gRPC, REST APIs, and databases.

To run tests against a protobuf file, you can use the following command:

```
buf test path/to/my.proto
```


This will run any tests that have been defined in the protobuf file, ensuring that it behaves as expected and catching any regressions.

Buf.build also supports code generation in various programming languages. To generate code from a protobuf file, you can use the following command:

```
buf generate path/to/my.proto
```


This will generate code in the specified language and output it to the appropriate directory.

V. Advanced Features of Buf.build

In addition to its basic features, Buf.build offers several advanced features that can further enhance your development experience. Some of these features include:

Configurable Linting Rules: Buf.build allows you to customize linting rules to fit your specific needs. You can enable or disable rules, adjust severity levels, and define custom rules.
Incremental Builds: Buf.build can perform incremental builds, which means that it only rebuilds what's necessary. This can speed up the build process and save time.
Remote Caching: Buf.build can use remote caching to speed up builds by reusing previously built artifacts. This can be especially useful in large codebases with many dependencies.
VI. Conclusion

Buf.build is a valuable tool for managing protobuf files and related code. It offers a fast, reliable, and easy-to-use way to lint, build, test, and generate code from protobuf files, making it ideal for managing large and complex codebases.

By using Buf.build, developers and organizations can improve code quality, speed up builds, and enable better collaboration between teams. Its advanced features, such as configurable linting rules, incremental builds, and remote caching, make it a powerful tool for managing protobufs at scale.

If you're new to Buf.build, we encourage you to give it a try and see how it can improve your development workflow. With its intuitive CLI and comprehensive documentation, getting started with Buf.build is easy and straightforward.

