---
title: 'Part 3 - Using Buf.build for managing gRPC plugins'
date: 2023-01-15T15:32:14Z
lastmod: '2022-05-05'
tags: ['grpc', 'buf', 'build tooling', 'plugin management']
draft: false
summary: 'Buf.build is a modern ecosystem simplifying the plugin management when building gRPC services and addresses several pains and short-comings found in the original gRPC build ecosystem'
layout: PostSimple
---

## Introduction

We concluded the [last part](/blog/grpc-series/simple-grpc-service/) by generating a grpc gateway service to act as a proxy in front of our grpc music service.  This service would convert familiar REST/HTTP requests from clients to/from our grpc services.  We also briefly discussing how the protoc utility orchestrates various plugins to generate various artifacts - solely via stdin and stdout.

In the same vein our REST/HTTP gateway was generated by using the grpc-gateway plugin and annotating our rpc methods by http method, bindings and parameter details (for further customization).  We also generated OpenAPI specs for our generated gateway service so it could be consumed via the SwaggerUI too.

A key part of our workflow so far was:

* using custom plugins (grpc-gateway)
* adding a call to the custom plugins in our Makefile (eg protoc `--<pluginname>_out=....`)
* copying vendor specific .proto files for custom annotations in our service specs.

To our dismay we also discovered protoc did not offer much in the way of package management so when it was time use Google's http annotations, we had to manually copy a bunch of third party/vendor proto files to access them.  Clearly this is a burden and only worsens as codebases become larger.  Even worse when code bases have dependencies to resolve (either from other parts of the codebases or from third party vendors) managing this burden because a daunting and error-prone task for developers.   Another area we have been carefully avoiding (but will only get harder with larger codebases) is that of testing, validation, collaboration between developers when using plugins in our grpc services.

What is needed are tools to:

* manage dependencies between proto packages within a project
* manage dependencies between several plugin/annotation providers
* generate artifacts and manage output dirs etc inherently instead of having to worry about output paths etc
* validate/enforce coding conventions and standards (via linting tools)
* improve collaboration between teams and organizations.

[Buf.build](https://buf.build/) is one such tool.  In this article we will provide a brief overview of Buf.build, its capabilities and guide you through the process of migrating our canonical running example - the musicservice - to use Buf.build for generating all required artifacts.   We will also remove any copied annotations and instead use Buf's package management facilities and repositories.

## What is Buf.build?

[Buf.build](https://github.com/bufbuild/buf) is an open source tool for managing protobuf files and plugins.   With Buf.build inting, building, testing protobuf files and code generation is simplified.  Buf.build makes it easier for developers (especially new to protobufs) to work with protobufs by unifiying several aspects of the related workflows under one roof.

Some of the key features of Buf.build are:
* **Repository management** for plugins for easy discovery and accessibility
* **Linting** for checking syntax errors and style violations in protobuf files
* **Testing** for protobuf files to ensure behaviours and catching any regressions
* **Building** protobuf files into binary and JSON representations to be used in several environments and contexts (gRPC, REST etc)
* **Code generation** for a variety of programming languages by invoking and managing plugins (without placing the burden of installing and maintaining these plugins on the developer).  This is especially valuble as a lot of repetitive tasks are automated saving valuble developer time.


There are several benefits to using Buf.build:

* By enforcing best practices via linting and testing, potential issues can be identified early on in the development cycle.  Syntax errors, style violations are just some of the issues that can be caught before they make it into production.  This results in maintainable and clean code.
* Builds are also sped up as only the changed and necessary parts can be rebuilt.  This would speeden the (code, build, test - and commit) inner loop of development improving time-to-market.
* Since plugins and annotations can now be managed in a single source (or set of repositories) sharing and collaboration between developers (within and across organizations) is easier and less error/conflict prone.   No longer would developers have to copy third-party protos into their work space and risk versions going out of sync.
* Increasing adoption in several organization to manage complex code bases also provides a feedback loop of more frequent updates, features and support for the wider community.

## Getting Started

Now that we have given a brief overview of Buf.build let us migrate our service to using this.  Detailed instructions are provided at the Buf.build [documentation](https://buf.build/docs/) pages and can be used for any updates.  This article is specifically focussed on updating an existing service (eg our musicservice) to use Buf.build.

### Installation

First install the Buf.build cli for your platform by following the instructions at Buf.build [installation page](https://buf.build/docs/installation).

eg, For OSX:
```
brew install bufbuild/buf/buf
```

### Configure [buf.yaml](https://buf.build/docs/tutorials/getting-started-with-buf-cli/#configure-buf)

In your protos root folder (musicservice/protos):

```
buf mod init
```

This would create a `buf.yaml` file.  Buf uses this file to determine and resolve import paths for all protos within this directory tree.  The protos can be tested by running `buf build`.

On a new project this would be error free.  But running it here would produce:

```
musicservice/v1/albums.proto:8:8:google/api/annotations.proto: does not exist
```

Rightly this indicates that we are depending on the google api annotations extensions but the dependency has not been specified.  To fix this add a new dependency in the buf.yaml file:


In the buf.yaml file, add a deps section:

**buf.yaml**:
```
version: v1
deps:
    - buf.build/googleapis/googleapis
breaking:
  use:
    - FILE
lint:
  use:
    - DEFAULT
```

Then run `buf mod update` to synchronize and lock the dependencies.  **Note:** `buf mod update` must be run every time `buf.yaml` is modified.

Now running `buf build` (from the protos folder) will result in no errors.

### Configure [buf.gen.yaml](https://buf.build/docs/tutorials/getting-started-with-buf-cli/#configure-a-bufgenyaml)

The `buf.yaml` file created earlier is used to mark the root of the protobuf files of a buf module (as you can guess - our module will eventually be called `musicservice`).  However we have still not marked/identified our actual module (or its root).  This module config is `buf.gen.yaml` and is placed in file in the root directory of your project.

Let us create this file (in the musicservice project root directory):

```
# cd musicservice
touch buf.gen.yaml
```

This yaml will contain information about the module such as version, plugins being used as well as other required bits of information (like the go_package_prefix).  Our buf.gen.yaml file looks like:

```
version: v1
managed:
  enabled: true
plugins:
  - plugin: go
    out: gen/go
    opt: paths=source_relative
  - plugin: go-grpc
    out: gen/go
    opt: paths=source_relative,require_unimplemented_servers=false
  - plugin: grpc-gateway
    out: gen/go
    opt: paths=source_relative
  # Python
  - plugin: buf.build/protocolbuffers/python
    out: gen/python
  - plugin: buf.build/grpc/python
    out: gen/python
  # Plain JS
  - plugin: buf.build/bufbuild/es
    out: gen/js
  - plugin: buf.build/bufbuild/connect-web
    out: gen/js
  # generate openapi documentation for api
  - remote: buf.build/grpc-ecosystem/plugins/openapiv2:v2.6.0-1
    out: gen/openapiv2
    opt: allow_merge=true,merge_file_name=services
```

Notice how adding a new plugin (for a new generator) is as adding another "plugin" entry in the plugins section of buf.gen.yaml file.  Just for fun we are also generating python and JS generated artifacts too!

As you may have observed, some plugins have an absolute name (eg "go", "go-grpc") and others have something that looks like a URL (buf.build/protocolbuffers/python, ....).  

Buf.build as mentioned earlier has a powerful plugin repository which can host and serve plugins for use.   Buf.build can *also* work with local plugins.   In a previous tutorial we had manually installed to `protoc-gen-go` and `protoc-gen-go-grpc` plugins in the `$GOBIN` folder.  If a plugin does not point to a URL (hosting the plugin) Buf.build simply invokes a local version of the plugin.  The options (via the "opt" attributes) are passed to the protoc tool as a flag for the plugin (eg `--go_opt=paths=source_relative`).

Now isn't *that* much more simplier and intuitive than installing each plugin locally and then adding commands to a Makefile (sorry oh mighty Makefile.  We shall not forget your sacrifice!)

To generate all the artifacts simply run `buf generate` from the root of your module (musicservice).  But before we do this, one more config file must be created.

### Configure [buf.work.yaml](https://buf.build/docs/configuration/v1/buf-work-yaml)

If we had run the above command at this point we would see the following error:

```
protos/musicservice/v1/albums.proto:7:8:musicservice/v1/models.proto: does not exist
```

Our protos folder had a single "module" in it.  Buf.build's allows us developers to work with *multiple* modules in the same workspace.  This is done by marking musicservice as a "workspace".   Create `buf.work.yaml` at the project root (musicservice) with the following contents:

```
version: v1
directories:
  - protos
```

This tells Buf.build that all protobuf definitions can be rooted in any of the directories given in the 'directories' attribute in the workspace definition file.   Now we can generate our artifacts:

```
rm -Rf gen        # just to convince ourselves
buf generate
```

This would generate all the artifacts in the gen folder - but without needing a Makefile and the various manual protoc commands.

`buf.work.yaml` allows us to have multiple (local) modules within a same workspace enabling more complicated structures like.  For example if our `buf.work.yaml` file's 'directories' attribute was:

```
version: v1
directories:
  - protos/stores_api
  - protos/radiostations_api
```

```
musicservice
├── buf.gen.yaml
├── buf.work.yaml
├── proto
    └── radiostations_api
        └── v2
            └── channels.proto
            └── showhosts.proto
    └── stores_api
        └── v1
            └── orders.proto
            └── shoppingcart.proto
```

For an indepth guide on how workspaces work checkout the [documentation](https://buf.build/docs/configuration/v1/buf-work-yaml).

## Other Features

### Linting

Buf.build also comes with an out of the box style guide for your protobuf definitions which can be used for consistency across teams.  Let us try it.

```
buf lint
```

Despite our best intent to version our service (and models) we see quite a few errors of the form:

```
protos/musicservice/v1/songs.proto:5:1:Files with package "musicservice" must be within a directory "musicservice" relative to root but were in directory "musicservice/v1".
protos/musicservice/v1/songs.proto:5:1:Package name "musicservice" should be suffixed with a correctly formed version, such as "musicservice.v1".
```

Let us fix this!  It is as simple as renaming the package names in the protobuf files from `musicservice` to `musicservice.v1`.  Not bad.

We also see another class of errors in terms of how messages should be named:

```
protos/musicservice/v1/labels.proto:74:18:RPC request type "ListAlbumsInLabelRequest" should be named "ListAlbumsRequest" or "LabelServiceListAlbumsRequest".
protos/musicservice/v1/labels.proto:74:53:RPC response type "ListAlbumsInLabelResponse" should be named "ListAlbumsResponse" or "LabelServiceListAlbumsResponse".
```

Here we were *close*.  We will chose LabelServiceListAlbumsRequest/Response (as `ListAlbumsRequest/Response` messages were already used in the Albums service).

`buf lint` now reveals no style violations!

## Advanced features

We have only scratched the surface of Buf.build.  Buf.build has several advanced features:

* [Configurable linting rules](https://buf.build/docs/lint/rules/): Allowing developers to customize linting rules, severity levels etc to suite the needs of teams.
* [Breaking change detection](https://buf.build/docs/breaking/overview/): An important part of service definition is to ensure that evolving them do not result in breaking changes (for older clients).  Buf.build provides checks for forward and backward compatibility of your service definitions.
* [Buf Schema Registry](https://buf.build/docs/tutorials/getting-started-with-bsr): Buf.build offers a power schema registry and repositories to host your own custom plugins and annotations.
* and many more.

See Buf.build [documentation](https://buf.build/docs/) for a full and indepth list of all features and capabilities.

## Conclusion

Buf.build vastly simplifies managing protobuf files and all related code.   Among its tool chain are a fast and easy to use linter, builder and generator for protobuf files targetting a variety of languages, protocols and platforms.  This has made it an ideal tool for managing complex codebases.

Buf.build usage improves developer velocity, code quality, iteration speeds and collaboration between teams.  It has also several advanced and customizable features to suit the specific needs of teams and organizations.

Give it a go!

