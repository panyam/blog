---
title: 'Part 3 - Using Buf.build for managing gRPC plugins'
date: 2023-01-15T15:32:14Z
lastmod: '2022-05-05'
tags: ['grpc', 'buf', 'build tooling', 'plugin management']
draft: false
summary: 'Buf.build is a modern ecosystem simplifying the plugin management when building gRPC services and addresses several pains and short-comings found in the original gRPC build ecosystem'
layout: PostSimple
---

## Introduction

We concluded the [last part](/blog/grpc-series/simple-grpc-service/) by generating a grpc gateway service to act as a proxy in front of our grpc music service.  This service would convert familiar REST/HTTP requests from clients to/from our grpc services.  We also briefly discussing how the protoc utility orchestrates various plugins to generate various artifacts - solely via stdin and stdout.

In the same vein our REST/HTTP gateway was generated by using the grpc-gateway plugin and annotating our rpc methods by http method, bindings and parameter details (for further customization).  We also generated OpenAPI specs for our generated gateway service so it could be consumed via the SwaggerUI too.

A key part of our workflow so far was:

* using custom plugins (grpc-gateway)
* adding a call to the custom plugins in our Makefile (eg protoc `--<pluginname>_out=....`)
* copying vendor specific .proto files for custom annotations in our service specs.

To our dismay we also discovered protoc did not offer much in the way of package management so when it was time use Google's http annotations, we had to manually copy a bunch of third party/vendor proto files to access them.  Clearly this is a burden and only worsens as codebases become larger.  Even worse when code bases have dependencies to resolve (either from other parts of the codebases or from third party vendors) managing this burden because a daunting and error-prone task for developers.   Another area we have been carefully avoiding (but will only get harder with larger codebases) is that of testing, validation, collaboration between developers when using plugins in our grpc services.

What is needed are tools to:

* manage dependencies between proto packages within a project
* manage dependencies between several plugin/annotation providers
* generate artifacts and manage output dirs etc inherently instead of having to worry about output paths etc
* validate/enforce coding conventions and standards (via linting tools)
* improve collaboration between teams and organizations.

[Buf.build](https://buf.build/) is one such tool.  In this article we will provide a brief overview of Buf.build, its capabilities and guide you through the process of migrating our canonical running example - the musicservice - to use Buf.build for generating all required artifacts.   We will also remove any copied annotations and instead use Buf's package management facilities and repositories.

## What is Buf.build?

[Buf.build](https://github.com/bufbuild/buf) is an open source tool for managing protobuf files and plugins.   With Buf.build inting, building, testing protobuf files and code generation is simplified.  Buf.build makes it easier for developers (especially new to protobufs) to work with protobufs by unifiying several aspects of the related workflows under one roof.

Some of the key features of Buf.build are:
* **Repository management** for plugins for easy discovery and accessibility
* **Linting** for checking syntax errors and style violations in protobuf files
* **Testing** for protobuf files to ensure behaviours and catching any regressions
* **Building** protobuf files into binary and JSON representations to be used in several environments and contexts (gRPC, REST etc)
* **Code generation** for a variety of programming languages by invoking and managing plugins (without placing the burden of installing and maintaining these plugins on the developer).  This is especially valuble as a lot of repetitive tasks are automated saving valuble developer time.


There are several benefits to using Buf.build:

* By enforcing best practices via linting and testing, potential issues can be identified early on in the development cycle.  Syntax errors, style violations are just some of the issues that can be caught before they make it into production.  This results in maintainable and clean code.
* Builds are also sped up as only the changed and necessary parts can be rebuilt.  This would speeden the (code, build, test - and commit) inner loop of development improving time-to-market.
* Since plugins and annotations can now be managed in a single source (or set of repositories) sharing and collaboration between developers (within and across organizations) is easier and less error/conflict prone.   No longer would developers have to copy third-party protos into their work space and risk versions going out of sync.
* Increasing adoption in several organization to manage complex code bases also provides a feedback loop of more frequent updates, features and support for the wider community.

## Getting Started

Now that we have given a brief overview of Buf.build let us migrate our service to using this.  Detailed instructions are provided at the Buf.build [documentation](https://buf.build/docs/) pages and can be used for any updates.  This article is specifically focussed on updating an existing service (eg our musicservice) to use Buf.build.

### Installation

First install the Buf.build cli for your platform by following the instructions at Buf.build [installation page](https://buf.build/docs/installation).

eg, For OSX:
```
brew install bufbuild/buf/buf
```

### Configure [buf.yaml](https://buf.build/docs/tutorials/getting-started-with-buf-cli/#configure-buf)

In your protos root folder (musicservice/protos):

```
buf mod init
```

This would create a `buf.yaml` file.  Buf uses this file to determine and resolve import paths for all protos within this directory tree.  

Before building our protos remove the folder `protos/google` which we had added earlier (to include google's http annotations).  We will replace this with a dependency that is hosted in and provided by Buf.build.

```
rm -Rf protos/google
```

In the buf.yaml file, add a deps section:

**buf.yaml**:
```
version: v1
deps:
    - buf.build/googleapis/googleapis
breaking:
  use:
    - FILE
lint:
  use:
    - DEFAULT
```

`buf build` from your project root (musicservice) can be invoked to generate all artifacts (much like `make all`) earlier but you now see a few errors (including this):

```
protos/google/api/annotations.proto:19:8:google/api/http.proto: does not exist
```

This erros occurs because:

This is because we are working from an existing project and we have not added any of the plugins or configured buf yet.  We shall do that now.  For now ignore this error.

### Configure [buf.gen.yaml]https://buf.build/docs/tutorials/getting-started-with-buf-cli/#configure-a-bufgenyaml)

The `buf.yaml` files in the proto folder is used to mark the root of a buf module (as you can guess - our module will eventually be called `musicservice`).  However we have still not marked/identified our actual module.  This module config is `buf.gen.yaml` and is placed in file in the root directory of your project.

Let us create this file (in the musicservice project root directory):

```
touch buf.gen.yaml
```

This yaml will contain information about the module such as version, plugins being used as well as other required bits of information (like the go_package_prefix).  Our buf.gen.yaml file looks like:

```
version: v1
managed:
  enabled: true
plugins:
  - plugin: go
    out: gen/go
    opt: paths=source_relative
  - plugin: go-grpc
    out: gen/go
    opt: paths=source_relative,require_unimplemented_servers=false
  - plugin: grpc-gateway
    out: gen/go
    opt: paths=source_relative
  # Python
  - plugin: buf.build/protocolbuffers/python
    out: gen/python
  - plugin: buf.build/grpc/python
    out: gen/python
  # Plain JS
  - plugin: buf.build/bufbuild/es
    out: gen/js
  - plugin: buf.build/bufbuild/connect-web
    out: gen/js
  # generate openapi documentation for api
  - remote: buf.build/grpc-ecosystem/plugins/openapiv2:v2.6.0-1
    out: gen/openapiv2
    opt: allow_merge=true,merge_file_name=services
```

Notice how adding a new plugin (for a new generator) is as adding another "plugin" entry in the plugins section of buf.gen.yaml file.  Just for fun we are also generating python and JS generated artifacts too!

As you may have observed, some plugins have an absolute name (eg "go", "go-grpc") and others have something that looks like a URL (buf.build/protocolbuffers/python, ....).  

Buf.build as mentioned earlier has a powerful plugin repository which can host and serve plugins for use.   Buf.build can *also* work with local plugins.   In a previous tutorial we had manually installed to `protoc-gen-go` and `protoc-gen-go-grpc` plugins in the `$GOBIN` folder.  If a plugin does not point to a URL (hosting the plugin) Buf.build simply invokes a local version of the plugin.  The options (via the "opt" attributes) are passed to the protoc tool as a flag for the plugin (eg `--go_opt=paths=source_relative`).

Now isn't *that* much more simplier and intuitive than installing each plugin locally and then adding commands to a Makefile (sorry oh mighty Makefile.  We shall not forget your sacrifice!)

```
buf lint path/to/my.proto
```

This will run the linting process and provide feedback on any syntax errors, style violations, or other issues in the protobuf file.

To build a protobuf file, you can use the following command:

```
buf build path/to/my.proto
```

This will generate the binary or JSON representation of the protobuf file, which can be used in various contexts such as gRPC, REST APIs, and databases.

To run tests against a protobuf file, you can use the following command:

```
buf test path/to/my.proto
```


This will run any tests that have been defined in the protobuf file, ensuring that it behaves as expected and catching any regressions.

Buf.build also supports code generation in various programming languages. To generate code from a protobuf file, you can use the following command:

```
buf generate path/to/my.proto
```


This will generate code in the specified language and output it to the appropriate directory.

V. Advanced Features of Buf.build

In addition to its basic features, Buf.build offers several advanced features that can further enhance your development experience. Some of these features include:

Configurable Linting Rules: Buf.build allows you to customize linting rules to fit your specific needs. You can enable or disable rules, adjust severity levels, and define custom rules.
Incremental Builds: Buf.build can perform incremental builds, which means that it only rebuilds what's necessary. This can speed up the build process and save time.
Remote Caching: Buf.build can use remote caching to speed up builds by reusing previously built artifacts. This can be especially useful in large codebases with many dependencies.
VI. Conclusion

Buf.build is a valuable tool for managing protobuf files and related code. It offers a fast, reliable, and easy-to-use way to lint, build, test, and generate code from protobuf files, making it ideal for managing large and complex codebases.

By using Buf.build, developers and organizations can improve code quality, speed up builds, and enable better collaboration between teams. Its advanced features, such as configurable linting rules, incremental builds, and remote caching, make it a powerful tool for managing protobufs at scale.

If you're new to Buf.build, we encourage you to give it a try and see how it can improve your development workflow. With its intuitive CLI and comprehensive documentation, getting started with Buf.build is easy and straightforward.

